;*
;*  TOPPERS Automotive Kernel
;*      Toyohashi Open Platform for Embedded Real-Time Systems
;*      Automotive Kernel
;*
;*  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
;*                              Toyohashi Univ. of Technology, JAPAN
;*  Copyright (C) 2004 by Embedded and Real-Time Systems Laboratory
;*              Graduate School of Information Science, Nagoya Univ., JAPAN
;*  Copyright (C) 2006 by Witz Corporation, JAPAN
;*  Copyright (C) 2006 by Hitachi,Ltd., Automotive Systems, JAPAN
;*  Copyright (C) 2006 by Hitachi Information & Control Solutions,Ltd., JAPAN
;*
;*  上記著作権者は，以下の (1)～(4) の条件か，Free Software Foundation
;*  によって公表されている GNU General Public License の Version 2 に記
;*  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
;*  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
;*  利用と呼ぶ）することを無償で許諾する．
;*  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
;*      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
;*      スコード中に含まれていること．
;*  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
;*      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
;*      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
;*      の無保証規定を掲載すること．
;*  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
;*      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
;*      と．
;*    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
;*        作権表示，この利用条件および下記の無保証規定を掲載すること．
;*    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
;*        報告すること．
;*  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
;*      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
;*
;*  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
;*  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
;*  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
;*  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
;*
;*

 	.INCLUDE "cpu_config.inc"
	.INCLUDE "sys_defs.inc"

;	外部参照宣言
	.IMPORT	_runtsk
	.IMPORT	_schedtsk
	.IMPORT	_tcxb_pc
	.IMPORT	_tcxb_sp
	.IMPORT	_tinib_task
	.IMPORT	_callevel
	.IMPORT	_runisr
	.IMPORT	_tinib_exepri
	.IMPORT	_tcb_curpri
	.IMPORT	_call_pretaskhook
	.IMPORT	_call_posttaskhook
	.IMPORT	_PreTaskHook
	.IMPORT	_PostTaskHook
	.IMPORT _int_ena_flag
	.IMPORT	_int_ena_level

 .AIF \&ENABLE_COMMON_STACK EQ 1
	.IMPORT _common_stack_top
 .AIF \&ENABLE_BCC_DEFINES EQ 1	; BCC defines symbols that SG does not output
	.EXPORT _tnum_exttask
 .AELSE
	.IMPORT _tnum_exttask
 .AENDI
 .AENDI

;	External public declaration
	.EXPORT	_dispatch
	.EXPORT	_start_dispatch
	.EXPORT	_exit_and_dispatch
	.EXPORT	_activate_r
	.EXPORT	_interrupt

 .AIF \&ENABLE_BCC_DEFINES EQ 1	; BCC defines symbols that SG does not output
	.EXPORT _tcb_curevt
	.EXPORT _tcb_waievt
 .AENDI

	.SECTION    P,CODE,ALIGN=4

;  In TOPPERS Automotive kernel, interrupt management uses the following two.
;	    IFLG: Interrupt enable flag
;       IPL: Interrupt mask level.
;  Since SH2 microcomputer has only the register corresponding to IPL,
;  it is soft and supplements IFLG
;		IFLG → int_ena_flag
;			While interrupt is enabled:   int_ena_flag = 1
;			while interrupt is disabled: int_ena_flag = 0
;		IPL  → SR register Interrupt mask bit
;			However, during disabling interrupt, save IPL to int_ena_level.
;
;  During task dispatching, it is locked by lock_cpu() (IFLG = 0, IPL = 0),
;  and after returning from dispatching, port it with unlock_cpu() in mind.


;
;	Task Dispatcher
;
;	Calling condition:
;		interrupt：IPL=0, IFLG=0 (CPU locked state)
;			→  SR=0xf0, int_ena_flag = 0, int_ena_level = 0
;		context：callevel=1(Task context)
;		stack： Task stack
;

_dispatch:
;	Save Register to Stack
	mov.l	 r8 , @-r15
	mov.l	 r9 , @-r15
	mov.l	r10 , @-r15
	mov.l	r11 , @-r15
	mov.l	r12 , @-r15
	mov.l	r13 , @-r15
	mov.l	r14 , @-r15
	sts.l	pr , @-r15
	sts.l	macl , @-r15		; MACH, MACL, GBR preserve callee by default in HEW
	sts.l	mach , @-r15		; Since the task that moves after the task becomes Waiting 
	stc.l	gbr , @-r15			; may destroy the MACH, MACL, save it. (※１)
 .AIF \&ENABLE_COMMON_STACK EQ 1
	mov.l	runtsk_adr , r0
 	mov.l	tnum_exttask_adr, r8
	mov.b	@r0 , r0
	mov.b	@r8 , r8
	extu.b	r0 , r0
	extu.b	r8 , r8
	cmp/gt	r0, r8				; test if runtsk < tnum_exttask
	bt/s	L001				; Jump if extended task
	shll2	r0					; Delayed branch slot Always execute
	mov.l	common_stack_top_adr , r10
	mov.l	dispatch_r_adr , r3	; Save execution resume address in TCB
	mov.l	tcxb_pc_adr , r2
	mov.l	r15 , @(r10)		; Save stack pointer on common stack
	bra		dispatcher			; To dispatcher
	mov.l	r3 , @(r0 , r2)		; Delay slot

L001:							; Extended task
	mov.l	tcxb_sp_adr , r2
	mov.l	dispatch_r_adr , r3
	mov.l	r15 , @(r0 , r2)	; Save stack pointer in TCB
	mov.l	tcxb_pc_adr , r2	; Save execution resume address in TCB
	bra		dispatcher			; To dispatcher
	mov.l	r3 , @(r0 , r2)		; Delay slot
 .AELSE	; ENABLE_COMMON_STACK
	mov.l	runtsk_adr , r1
	mov.b	@r1 , r0
	extu.b	r0 , r0
	shll2	r0
	mov.l	tcxb_sp_adr , r2
	mov.l	r15 , @(r0 , r2)	; Save stack pointer in TCB
	mov.l	dispatch_r_adr , r3
	mov.l	tcxb_pc_adr , r2	; Save execution resume address in TCB
	mov.l	r3 , @(r0 , r2)		; Delay slot
	bra		dispatcher			; To dispatcher
	nop
 .AENDI ; ENABLE_COMMON_STACK

	.align	4
dispatch_r_adr:
	.DATA.L	dispatch_r

; (※１) The task enters the wait state by WaitEvent () etc, 
;       and the task with the low priority operates the MACH, MACL.
;　In the meantime, when SetEvent () etc. is executed by the processing of ISR 2,
;  MACH and MACL at task dispatch are the values of the preempted task.

;
;	Calling condition:
;	 	interrupt：IPL=0, IFLG=0 (CPU locked state)
;			→  SR=0xf0, int_ena_flag = 0, int_ena_level = 0
;		context：callevel=1(Task context)
;		stack： Task stack
;

	.align	2
dispatch_r:
;	Register recovery from task stack
	ldc.l	@r15+ , gbr
	lds.l	@r15+ , mach
	lds.l	@r15+ , macl
	lds.l	@r15+ ,  pr
	mov.l	@r15+ , r14
	mov.l	@r15+ , r13
	mov.l	@r15+ , r12
	mov.l	@r15+ , r11
	mov.l	@r15+ , r10
	mov.l	@r15+ ,  r9
	mov.l	@r15+ ,  r8		; Delay slot
	rts						; dispatch Return to the caller.
	nop


;
;	Task activation processing
;	In this case, put the CPU unlocked state and start the task.
;		（SR=0、int_ena_flag = 1）
;
;	Outgoing conditions:
;		interrupt：IFLG=0 (CPU locked state), Task stack
;			→  SR=0xf0, int_ena_flag = 0, int_ena_level = 0
;			  (Within dispatcher processing, you must set int_ena_level = 0)
;		Context: callevel = 1 (task context)
;		Stack: Task stack

	.align	2
_activate_r:
 .AIF \&ENABLE_COMMON_STACK EQ 1
	mov.l	runtsk_adr	,r0			; Execution start task ID
 	mov.l	tnum_exttask_adr, r5
	mov.b	@r0 , r0
	mov.b	@r5 , r5
	extu.b	r0 , r0
	mov.l	tinib_exepri_adr , r6	; Read initial priority
	mov.l	tcb_curpri_adr , r7		; Set as current priority
	mov.b	@(r0 , r6) , r6
	extu.b	r5 , r5
	mov.b	r6 , @(r0 , r7)
	cmp/gt	r0, r5				; test if runtsk < tnum_exttask
	bt/s	L101				; Jump if extended task
	shll2	r0					; Delayed branch slot Always execute
	mov.l	tcxb_sp_adr , r2	; SP area in TCB
	mov.l	r15 , @(r0 , r2)	; Save stack pointer (initial value) in TCB

L101:							; Common part
 	mov.l	int_ena_flag_adr, r4	; CPU unlock
	mov.l	tinib_task_adr , r1		; Task entry point
	mov		#1 , r3
 	mov.l	r3, @r4
	mov.l	@(r0 , r1) , r2
	mov		#0 , r3
	jmp		@r2
	ldc		r3 , sr					; Delay slot, interrupt enable
 .AELSE	; ENABLE_COMMON_STACK
	mov.l	runtsk_adr	,r2			; Execution start task ID
	mov.b	@r2 , r0
	extu.b	r0 , r0
	mov.l	tinib_exepri_adr , r2	; Read initial priority
	mov.b	@(r0 , r2) , r1
	extu.b	r1 , r1
	mov.l	tcb_curpri_adr , r3		; Set as current priority
	mov.b	r1 , @(r0 , r3)

	mov		#1 , r3
 	mov.l	int_ena_flag_adr, r1	; CPU unlock
 	mov.l	r3, @r1
	mov		#0 , r3
	shll2	r0
	mov.l	tinib_task_adr , r1
	mov.l	@(r0 , r1) , r2
	jmp		@r2
	ldc		r3 , sr					; Delay slot, interrupt enable
 .AENDI ; ENABLE_COMMON_STACK

	.align	4
tinib_exepri_adr:
	.DATA.L	_tinib_exepri
tcb_curpri_adr:
	.DATA.L	_tcb_curpri
tinib_task_adr:
	.DATA.L	_tinib_task

;
;	dispatcher Calling condition:
;		・The context of all tasks is saved.
;		・IFLG=0 (CPU locked state),
;		  → SR = 0xf0, int_ena_flag = 0, int_ena_level = 0
;             Since IPL = 0 during task execution, set int_ena_level = 0 so that SR = 0
;             when unlock_cpu () is executed after returning.
;			  However, when entering dispatcher after interrupt processing,
;             it may be overwritten by lock_cpu in ISR 2, so make intmask = 0 
;             at the interrupt processing exit.
;
;		・Context is the task context (callevel = 1) except at kernel startup
;			The initial value of callevel is 1?
;			At startup, it is a non-task context (callevel != 1), and even in that case.
;	dispatcher Stack at call:
;		From __kernel_dispatch: Task stack
;		From exit_and_dispatch:
;			If it comes from exit_task, the task stack
;			Interrupt stack at kernel start
;		When it comes from ret_int: Task stack
;		When waiting for interrupt at dispatcher_1: Interrupt stack
;

	.align	2
_exit_and_dispatch:
 .AIF \&ENABLE_COMMON_STACK EQ 1
	mov.l	runtsk_adr , r0
 	mov.l	tnum_exttask_adr, r1
	mov.b	@r0 , r0
	mov.b	@r1 , r1
	extu.b	r0 , r0
	extu.b	r1 , r1
	cmp/gt	r0, r1				; test if runtsk < tnum_exttask
	bt		dispatcher			; When doing an extended task, do not do anything
	shll2	r0
	mov.l	tcxb_sp_adr , r2
	mov.l	common_stack_top_adr , r1
	mov.l	@(r0 , r2), r15		; Restore stack pointer to initial value
	mov.l	r15, @(r1)			; Save to top of stack
 .AENDI	; ENABLE_COMMON_STACK

dispatcher:
; Call post task hook
	mov.l	PostTaskHook_adr , r0
	tst		r0 , r0
	bt		_start_dispatch
	mov.l	call_posttaskhook_adr , r0
	jsr		@r0
	nop
_start_dispatch:
 .AIF \&ENABLE_COMMON_STACK EQ 1
	mov.l	schedtsk_adr, r0	; schedtsk to runtsk
	mov.l	runtsk_adr , r1
	mov.b	@r0 , r2
 	mov.l	tnum_exttask_adr, r8
	extu.b	r2 , r2
	mov.b	@r8 , r8
	mov.l	INVALID_TASK_adr , r4
	mov.b	r2 , @r1
	cmp/eq	r4 , r2				; If schedtsk is invalid, go to idle loop
	bt		pre_idle

	extu.b	r8 , r8
	cmp/gt	r2, r8				; test if runtsk < tnum_exttask
	bt/s	L201				; Jump if extended task
	shll2	r2					; Delay slot
	mov.l	common_stack_top_adr , r9
	bra	L202
	mov.l	@(r9) , r15			; Delay slot / Set task stack pointer

L201:							; Extended task
	mov.l	tcxb_sp_adr , r0
	mov.l	@(r0 , r2) , r15	; Return task stack pointer

L202:
	mov.l	tcxb_pc_adr , r0
	mov.l	PreTaskHook_adr , r1
	mov.l	@(r0 , r2) , r8		; r8 is saved in PreTaskHook
	tst		r1 , r1
	bf		L203
	jmp		@(r8)				; Jump to task return address
	nop
L203:
	mov.l	call_pretaskhook_adr , r1
	jsr		@r1
	nop
	jmp		@r8				; Return address
	nop
 .AELSE	; ENABLE_COMMON_STACK
	mov.l	schedtsk_adr, r0	; schedtsk to runtsk
	mov.b	@r0 , r2
	extu.b	r2 , r2
	mov.l	runtsk_adr , r1
	mov.b	r2 , @r1

	mov.l	INVALID_TASK_adr , r0
	cmp/eq	r0 , r2				; If schedtsk is invalid, go to idle loop
	bt		pre_idle
	shll2	r2
	mov.l	tcxb_sp_adr , r0
	mov.l	@(r0 , r2) , r15	; Return task stack pointer
	mov.l	tcxb_pc_adr , r0
	mov.l	@(r0 , r2) , r3
	mov.l	PreTaskHook_adr , r1
	tst		r1 , r1
	bt		PreTaskHook_r
	mov.l	call_pretaskhook_adr , r1
	mov.l	r3 , @-r15			; Return for PC for PreTaskHook Save the stack on the stack
	jsr		@r1
	nop
	mov.l	@r15+ , r3		; Return return PC
PreTaskHook_r:
	jmp		@r3				; Return address
	nop
 .AENDI	; ENABLE_COMMON_STACK

	.align	4
PreTaskHook_adr:
	.DATA.L	_PreTaskHook
PostTaskHook_adr:
	.DATA.L	_PostTaskHook
call_pretaskhook_adr:
	.DATA.L	_call_pretaskhook
call_posttaskhook_adr:
	.DATA.L	_call_posttaskhook

;
;	From here no schedtsk
;
	.align	2
pre_idle:
;
; Here, switching to the non-task context and interrupt stack has two meanings:
; solving the problem of which stack is used for interrupt processing generated here,
; and prevention of dispatch in the interrupt handler.
;
	mov.l	STACK_TOP_adr, r15		; Switch to interrupt stack
	mov.l	callevel_adr , r0
	mov		#TCL_ISR2 , r1
	mov.b	r1 , @r0			; Non-task context
; Preparation of idle loop
	mov		#1 , r2
	mov.l	int_ena_flag_adr , r8	; Unlock CPU
	mov.l	r2 , @r8
	mov		#0 , r2
	mov.l	MAX_IPM_adr , r3
	mov.l	schedtsk_adr , r5
	mov.l	INVALID_TASK_adr , r4
idle_loop:
	ldc		r2 , sr				; Waiting for interrupt
	nop
	ldc		r3 , sr				; Interrupt disabled
	mov.b	@r5 , r1			; Read schedtsk
	extu.b	r1 , r1
	cmp/eq	r4 , r1				; Is there a task to be scheduled?
	bt		idle_loop			; Again idle loop

	mov.l	r2 , @r8			; Lock CPU
 	mov.l	int_ena_level_adr, r4		; Since int_ena_level may have changed during interrupt processing, set it to 0
 	mov.l	r2, @r4				;  (At this time, r2 = 0)
	mov		#TCL_TASK , r3
	mov.b	r3 , @r0			; Return callevel to TASK level
	bra		_start_dispatch		; To Dispatcher
	nop


;
; Interrupt handler exit processing (with dispatch request)
; Since it is dispatching after an interruption occurs during task execution,
; first, the remaining registers are saved.
; When dispatching tasks, set the CPU lock state.(int_ena_flag=0, int_ena_level=0)
; Since int_ena_level is other than 0 in lock_cpu () of ISR 2, int_ena_level = 0.
;
;	Calling condition:
;	・IFLG=0, IPL=0, Task context(callevel=1)
;	  →SR=0xf0, int_ena_flag = 1, int_ena_level = unknown, Task context(callevel=1)
;	・Used stack is task stack
;	・The task context is r0 - r7, mach, machl, gbr, pr are stacked on the stack
;
	.align	2
ret_int:
	; Save remaining registers
	mov.l	r8 , @-r15
	mov.l	r9 , @-r15
	mov.l	r10 , @-r15
	mov.l	r11 , @-r15
	mov.l	r12 , @-r15
	mov.l	r13 , @-r15
	mov.l	r14 , @-r15
 .AIF \&ENABLE_COMMON_STACK EQ 1
	mov.l	#0, r8					; Since dispatch is in progress, put the CPU locked state
 	mov.l	int_ena_flag_adr, r9
 	mov.l	int_ena_level_adr, r10		; During dispatch, int_ena_level = 0
 	mov.l	tnum_exttask_adr, r11		;
 	mov.l	r8, @r9
 	mov.b	@r11, r11
 	mov.l	r8, @r10
 	extu.b	r11, r11
	cmp/gt	r0, r11				; test if runtsk < tnum_exttask (runtsk is in r0）
	bt/s	L301				; Jump if extended task
	shll2	r0					; Delayed branch slot Always execute
	mov.l	common_stack_top_adr , r10
	bra		L302
	mov.l	r15 , @(r10)		; Delay Slot / Save Stack Pointer
L301:							; Extended task
	mov.l	tcxb_sp_adr , r1
	mov.l	r15 , @(r0 , r1)		; Save stack pointer
L302:
	mov.l	tcxb_pc_adr , r1
	mov.l	ret_int_r_adr , r2		; Set return address to ret_int_r
	bra		dispatcher				; To Dispatcher
	mov.l	r2 , @(r0 , r1)			; Delay slot / Save return address
 .AELSE ; ENABLE_COMMON_STACK
	mov.l	#0, r8					; Since dispatch is in progress, put the CPU locked state
 	mov.l	int_ena_flag_adr, r9
 	mov.l	r8, @r9
 	mov.l	int_ena_level_adr, r9			; During dispatch, int_ena_level=0
 	mov.l	r8, @r9
	shll2	r0						; runtsk is in r0
	mov.l	tcxb_sp_adr , r1
	mov.l	r15 , @(r0 , r1)		; Save stack pointer
	mov.l	tcxb_pc_adr , r1
	mov.l	ret_int_r_adr , r2		; Set return address to ret_int_r
	mov.l	r2 , @(r0 , r1)			; Save stack pointer
	bra		dispatcher				; To Dispatcher
	nop
 .AENDI ; ENABLE_COMMON_STACK

	.align	4
ret_int_r_adr:
	.DATA.L	ret_int_r

;
;  Interrupt exit processing to task preempted by interrupt
;
;	Calling condition:
;		割込み：IFLG=0 (CPUロック状態), タスクスタック
;			→  SR=0xf0, int_ena_flag = 0, int_ena_level = 0
;			  （dispatcher 処理内で、int_ena_level =0 に設定しておくこと）
;		コンテキスト：callevel=1(タスクコンテキスト)
;		スタック： タスクスタック
;	スタックにはr14-r8,gbr,mach,machl,pr,r7-r0の順で積まれている
;
;		通常のディスパッチでは無いため、割込み復帰時に、通常のタスク実行状態
;		である 割込み許可状態に戻す。
;		RTE命令では、割込み時の SR しか復帰しないため、int_ena_flag = 1 に設定する。
;
	.align	2
ret_int_r:
	mov.l	#1, r8					; Return to preempted task
 	mov.l	int_ena_flag_adr, r9	; Cancel CPU lock state
 	mov.l	r8, @r9
	mov.l	@r15+ , r14				; Reset registers
	mov.l	@r15+ , r13
	mov.l	@r15+ , r12
	mov.l	@r15+ , r11
	mov.l	@r15+ , r10
	mov.l	@r15+ , r9
	mov.l	@r15+ , r8
	ldc.l	@r15+ , gbr
	lds.l	@r15+ , mach
	lds.l	@r15+ , macl
	lds.l	@r15+ , pr
	mov.l	@r15+ , r7
	mov.l	@r15+ , r6
	mov.l	@r15+ , r5
	mov.l	@r15+ , r4
	mov.l	@r15+ , r3
	mov.l	@r15+ , r2
	mov.l	@r15+ , r1
	mov.l	@r15+ , r0		; Delay slot
	rte						; Return to interrupt source
	nop
	.align	4
int_ena_flag_adr:
	.DATA.L	_int_ena_flag
int_ena_level_adr:
	.DATA.L	_int_ena_level

;
;	Interrupt gateway processing (assembly language description part)
;
;	Calling condition:
;	・I bit of FLG register=0, IPL is the IPL of accepted interrupt.
;	→It should be called after setting SR = 0xf0, int_ena_flag = 0.
;     Also, when transferring control to ISR 2 body, int _ena _ flag = 1 should be reset.
;	  However, since SR = 0xf0 has not already been interrupted, int_ena_flag setting is omitted.
;
;	・The stack is an interrupt stack if there are multiple interrupts,
;     otherwise the task stack
;	・r0 The address of the interrupt handler is stored.
;	・r1 The interrupt ID in the previous execution is stored.
;	・r2 The value of SR register at interrupt acceptance is stored
;
;	The following shows how registers are stored on the stack.
;	In this figure, it is assumed that the stack is stacked from the bottom to the top 
;  with the address at the top being low and the bottom at the high.
;
;	-------------------------
;	|       R3(4byte)        |
;	--------------------------
;	|       R2(4byte)        |
; *	--------------------------
;	|       R1(4byte)        |
;	--------------------------
;	|       R0(4byte)        |
;	--------------------------
;	|       PC(4byte)        | <- PC restored from interrupt (saved with H/W)
;	--------------------------
;	|       SR(4byte)        | <- SR register at interrupt occurrence (saved in H/W)
;	--------------------------
;
; The stack after saving the remaining registers in the interrupt common section is shown below.
;	-------------------------
;	|      GBR(4byte)        |
;	-------------------------
;	|     MACH(4byte)        |
;	-------------------------
;	|     MACL(4byte)        |
;	-------------------------
;	|       PR(4byte)        |
;	-------------------------
;	|       R7(4byte)        |
;	-------------------------
;	|       R6(4byte)        |
;	-------------------------
;	|       R5(4byte)        |
;	-------------------------
;	|       R4(4byte)        |
;	-------------------------
;	|       R3(4byte)        |
;	--------------------------
;	|       R2(4byte)        |
;	--------------------------
;	|       R1(4byte)        |
;	--------------------------
;	|       R0(4byte)        |
;	--------------------------
;	|       PC(4byte)        | <- PC restored from interrupt (saved with H/W)
;	--------------------------
;	|       SR(4byte)        | <- SR register at interrupt occurrence (saved in H/W)
;	--------------------------
;
;	The register loaded on the stack with ret_int at the time of delayed dispatch request
;	It is shown below.
;
;	-------------------------
;	|      R14(4byte)        |
;	-------------------------
;	|      R13(4byte)        |
;	-------------------------
;	|      R12(4byte)        |
;	--------------------------
;	|      R11(4byte)        |
;	--------------------------
;	|      R10(4byte)        |
;	--------------------------
;	|       R9(4byte)        |
;	-------------------------
;	|       R8(4byte)        |
;	-------------------------
;	|      GBR(4byte)        |
;	-------------------------
;	|     MACH(4byte)        |
;	-------------------------
;	|     MACL(4byte)        |
;	-------------------------
;	|       PR(4byte)        |
;	-------------------------
;	|       R7(4byte)        |
;	-------------------------
;	|       R6(4byte)        |
;	-------------------------
;	|       R5(4byte)        |
;	-------------------------
;	|       R4(4byte)        |
;	-------------------------
;	|       R3(4byte)        |
;	--------------------------
;	|       R2(4byte)        |
;	--------------------------
;	|       R1(4byte)        |
;	--------------------------
;	|       R0(4byte)        |
;	--------------------------
;	|       PC(4byte)        | <- PC restored from interrupt (saved with H/W)
;	--------------------------
;	|       SR(4byte)        | <- SR register at interrupt occurrence (saved in H/W)
;	--------------------------
;
;	After returning from the handler, not multiple interrupts,
;	When there is a dispatch request (schedtsk != runtsk)
;	Branch to ret_int.
;
;	When branching to ret_int and dispatching a task Forcibly sets the value of IPL to 0.
;	Since there is no way to set IPL to 0 after dispatching, do it here.
;	With regard to this processing, it is judged that there is no problem 
;   under the prerequisite below.
;	・IPL = 0 during normal task operation, and IPL = 0 even after interrupt / dispatch.
;	・When an interrupt occurs at resource acquisition IPL != 0,
;     the processing level of each task in the executable state is the task level.
;	　Dispatching does not occur because the processing level of the task that was being
;     executed at the time of interrupt occurrence is the interrupt level (IPL != 0).
;	・When dispatching occurs from these, IPL = 0 and there is no problem.
;
;   In the implementation of SH2, the value of int_ena_level is set to SR 
;   in processing of unlock_cpu() after dispatching.
;   That is, in ret_int, it is sufficient to set int_ena_level = 0.
;
;	Whether multiple interrupts or not is determined by the value of callevel.
;	If callevel != 1, it is determined to be multiple interrupts.
;
;
	.align	2
_interrupt:
; Evacuate the remaining stack
	mov.l	r4 , @-r15
	mov.l	r5 , @-r15
	mov.l	r6 , @-r15
	mov.l	r7 , @-r15
	sts.l	pr , @-r15
	sts.l	macl , @-r15
	sts.l	mach , @-r15
	stc.l	gbr , @-r15
	mov		#TCL_TASK , r4		; Check if it is multiple interrupt
	mov.l	callevel_adr , r3
	mov.b	@r3 , r5
	cmp/eq	r4 , r5
	bf int_from_int
int_from_task:
 .AIF \&ENABLE_COMMON_STACK EQ 1
	mov.l	runtsk_adr, r4
	mov.l	tnum_exttask_adr, r6
	mov.b	@r4, r4
	mov.b	@r6, r6
	extu.b	r4, r4
	extu.b	r6, r6
	cmp/gt	r4, r6				; test if runtsk < tnum_exttask
	bf		L501				; Jump if basic task
	mov.l	common_stack_top_adr , r4
	bra		L502
	mov.l	@r4, r4				; Delay slot
L501:							; Basic Task
	mov.l	r15, r4
L502:
	mov.l	r15 , @-r4
	mov		r4 , r15
	mov		#TCL_ISR2 , r6		; Change call level
	mov.b	r6 , @r3
 .AELSE	; ENABLE_COMMON_STACK
	mov.l	STACK_TOP_adr , r4		; Switch stack
	mov.l	r15 , @-r4
	mov		r4 , r15
	mov		#TCL_ISR2 , r6		; Change call level
	mov.b	r6 , @r3
 .AENDI	; ENABLE_COMMON_STACK
int_from_int:
	mov.w	r1 , @-r15			; Save the previous interrupt ID on the stack
	mov.w	r5 , @-r15			; Save the previous execution level on the stack
								; ここでワードで保存しているのは、
								; SPを4バイト境界に保つためである
	ldc		r2 , sr				; Interrupt enabled (return to ISR 2 interrupt level)
	jsr		@r0					; Interrupt routine call
	nop
	mov.l	MAX_IPM_adr , r0	; Interrupt disabled
	ldc		r0 , sr
	mov.w	@r15+ , r0			; Restore the previous execution level
	mov.l	callevel_adr , r1
	mov.b	r0 , @r1
	mov.w	@r15+ , r2			; Return previous interrupt ID
	mov.l	runisr_adr , r1
	mov.b	r2 , @r1
	mov		#TCL_TASK , r1		; Is it multiple interrupt?
	cmp/eq	r0 , r1
	bf		int_return

; Process to restore from the first stage interrupt
	mov.l	@r15 , r15			; Return to task stack
	mov.l	callevel_adr , r2
	mov.b	r1 , @r2

; Confirm whether there is an interrupt at the interrupt entrance
	mov		r15 , r0
	mov.l	@(52, r0) , r0		; Extract SR register before interrupt
	mov.l	IPM_MASK_adr , r1	; Mask and retrieve IPM
	and		r1 , r0
	tst		r0 , r0				; Check if it is 0
	bf		int_return			; If it is not 0, multiple interrupt

	mov.l	runtsk_adr , r1		; Is there a dispatch request?
	mov.b	@r1 , r0
	extu.b	r0 , r0
	mov.l	schedtsk_adr , r1
	mov.b	@r1 , r2
	extu.b	r2 , r2
	cmp/eq	r0 , r2
	bf		ret_int
int_return:
	ldc.l	@r15+ , gbr		; Reset registers
	lds.l	@r15+ , mach
	lds.l	@r15+ , macl
	lds.l	@r15+ , pr
	mov.l	@r15+ , r7
	mov.l	@r15+ , r6
	mov.l	@r15+ , r5
	mov.l	@r15+ , r4
	mov.l	@r15+ , r3
	mov.l	@r15+ , r2
	mov.l	@r15+ , r1
	mov.l	@r15+ , r0		; Delay slot
	rte						; Return to interrupt source
	nop


; Processing of unused interrupts
	.EXPORT _unused_interrupt
_unused_interrupt:
;	bra	_unused_interrupt
	nop
	rte
	nop

	.align	4
runtsk_adr:
	.DATA.L	_runtsk
schedtsk_adr:
	.DATA.L	_schedtsk
tcxb_sp_adr:
	.DATA.L	_tcxb_sp
tcxb_pc_adr:
	.DATA.L	_tcxb_pc
STACK_TOP_adr:
	.DATA.L	STACK_TOP
callevel_adr:
	.DATA.L	_callevel
runisr_adr:
	.DATA.L	_runisr
MAX_IPM_adr:
	.DATA.L  MAX_IPM << 4	; SR register value when interrupt is disabled
IPM_MASK_adr:
	.DATA.L	H'000000F0		; Interrupt mask bit of SR register
INVALID_TASK_adr:
	.DATA.L	INVALID_TASK
 .AIF \&ENABLE_COMMON_STACK EQ 1
tnum_exttask_adr:
	.DATA.L _tnum_exttask
common_stack_top_adr:
	.DATA.L _common_stack_top
 .AENDI

 .AIF \&ENABLE_BCC_DEFINES EQ 1		; BCC defines symbols that SG does not output
 	.SECTION    C,DATA,ALIGN=4
_tnum_exttask:
	.DATA.B	0			; The number of extended tasks is fixed to 0
_tcb_curevt: .EQU	0	; Because there is no program to be accessed, set the address to 0
_tcb_waievt: .EQU	0
 .AENDI

;/* Definition of constants */
TCL_ISR2:	.EQU	2
TCL_TASK:	.EQU	1
INVALID_TASK:	.EQU	H'ff



	.end
